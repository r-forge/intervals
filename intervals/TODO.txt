- (6 April 2008) For real-valued interval endpoints, we may have some serious
  problems with floating point precision and assessing whether different
  endpoints are "equal". This is especially important when one interval ends
  where another begins, or when query and target begin at the same location for
  an interval_overlap() call -- since the algorithm requires us to get queries
  and targets handled in the proper order when the endpoints are identical.

  One solution will be to use a tolerance argument as all.equal() does. I still
  need to work out just how I want to go about this. This might be as simple as
  using round(), with the appropriate precision, before doing sorting. The
  resulting ordering could then optionally be compared to what would have
  resulted with a straight order() call, and a warning could be generated if the
  results do not agree.

- (6 April 2008) If we force an integer data type for "Z" interval matrices,
  perhaps this will keep users from inserting invalid endpoints into an existing
  object. Although perhaps not... R will just update the matrix data type on the
  fly, and will probably not call the validity function for the containing
  object. 

  (5 May 2008) An alternative here -- one which is probably more natural -- is
  to just determine endpoint type on the basis of the data types of the
  matrices. One or more real-valued matrices causes real-line
  computation. Possibly provide a utility L(), to make numeric matrices
  integral, generating a warning if rounding is required. Also add a switch to
  all functions which behaves in the same way.

  It should be the case that we ALWAYS use the type() accessor for checking and
  setting matrix types -- except in class definitions, initialize methods, and
  the definition of the type() accessors themselves. If so, it will be simple to
  drop the explicit slot and do as described in the preceeding paragraphs.

- (7 May 2008) In the end, I should probably leave accessors intact but NOT use
  replacement methods in my own code -- since these create efficiency problems
  due to copying.

- (30 May 2008) The ordering_matrix approach currently used in interval_union is
  a bit awkward (though efficient), and should probably be replaced with
  something in C++ which is consistent with how intervalsOverlap is implemented.

- (30 May 2008) Consider replacing coerce methods with setAs. In particular,
  it's disappointing to see that as.matrix doesn't work currently.

- (30 May 2008) When combining or working with mixed objects, automatically move
  up to Intervals_full if any of the objects are of this class. We may be able
  to do this in the combine method only: all other methods working on more than
  one object probably use this at some point to put things together.

- (1 June 2008) Can we use R's all.equal for equality checking? This would make
  for consistent results, whereas implementing our own verison in the C code
  would (i) be more work and (ii) likely be inconsistent in some cases. Note
  that this is required for BOTH interval_overlap and for interval_union.

  PSEUDO-CODE FOR R all.equal.numeric

  - Set tolerance = .Machine$double.eps^0.5.

  - Only check non-NA pairs for which == fails.

  - Set xy to the mean absolute difference (along the vectors).

  - Set xn to the mean absolue target.

  - If xn > tolerance, make a relative comparison and set xy to
    xy/xn. Otherwise, make an absolute comparison and leave xy as it is.

  - Return equality iff xy <= tolerance.

Note: dropping entries for which == holds is important, as it affects the means
below. We will, however most likely apply our procedure to single pairs of
numbers, so it won't matter: if == holds, then the relative difference is 0 in
any case. An important issue: R's relative difference is abs( tar - cur )  /
tar. The traditional definition, however, is abs( tar - cur ) / max( tar, cur
). On the other hand, the comp.lang.c FAQ first uses R's version, then the
traditional relative difference.
