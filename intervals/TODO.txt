- (6 April 2008) If we force an integer data type for "Z" interval matrices,
  perhaps this will keep users from inserting invalid endpoints into an existing
  object. Although perhaps not... R will just update the matrix data type on the
  fly, and will probably not call the validity function for the containing
  object. 

  (5 May 2008) An alternative here -- one which is probably more natural -- is
  to just determine endpoint type on the basis of the data types of the
  matrices. One or more real-valued matrices causes real-line
  computation. Possibly provide a utility L(), to make numeric matrices
  integral, generating a warning if rounding is required. Also add a switch to
  all functions which behaves in the same way.

  It should be the case that we ALWAYS use the type() accessor for checking and
  setting matrix types -- except in class definitions, initialize methods, and
  the definition of the type() accessors themselves. If so, it will be simple to
  drop the explicit slot and do as described in the preceeding paragraphs.

- (7 May 2008) In the end, I should probably leave accessors intact but NOT use
  replacement methods in my own code -- since these create efficiency problems
  due to copying.

- (30 May 2008) The ordering_matrix approach currently used in interval_union is
  a bit awkward (though efficient), and should probably be replaced with
  something in C++ which is consistent with how intervalsOverlap is implemented.

- (30 May 2008) Consider replacing coerce methods with setAs. In particular,
  it's disappointing to see that as.matrix doesn't work currently.

- (30 May 2008) When combining or working with mixed objects, automatically move
  up to Intervals_full if any of the objects are of this class. We may be able
  to do this in the combine method only: all other methods working on more than
  one object probably use this at some point to put things together.

- (1 June 2008) Can we use R's all.equal for equality checking? This would make
  for consistent results, whereas implementing our own verison in the C code
  would (i) be more work and (ii) likely be inconsistent in some cases. Note
  that this is required for BOTH interval_overlap and for interval_union.

  PSEUDO-CODE FOR R all.equal.numeric

  - Set tolerance = .Machine$double.eps^0.5.

  - Only check non-NA pairs for which == fails.

  - Set xy to the mean absolute difference (along the vectors).

  - Set xn to the mean absolue target.

  - If xn > tolerance, make a relative comparison and set xy to
    xy/xn. Otherwise, make an absolute comparison and leave xy as it is.

  - Return equality iff xy <= tolerance.

  Note: dropping entries for which == holds is important, as it affects the means
  below. We will, however most likely apply our procedure to single pairs of
  numbers, so it won't matter: if == holds, then the relative difference is 0 in
  any case. An important issue: R's relative difference is abs( tar - cur )  /
  tar. The traditional definition, however, is abs( tar - cur ) / max( tar, cur
  ). On the other hand, the comp.lang.c FAQ first uses R's version, then the
  traditional relative difference.

  THIS IS NOW FINISHED FOR INTERVAL_OVERLAP, BUT STILL NEEDS TO BE DONE FOR
  INTERVAL_UNION, WHICH WILL PROBABLY MOVE TO C++ IN ANY CASE.
